/*
 * Target.h
 *
 *  Created on: Jul 4, 2019
 *      Author: rayvburn
 */

#ifndef INCLUDE_CORE_TARGET_H_
#define INCLUDE_CORE_TARGET_H_

#include <tuple>
#include <gazebo/physics/Model.hh>
#include <gazebo/physics/World.hh>	// WorldPtr
#include <ignition/math/Vector3.hh>
#include <queue>
#include <gazebo/common/Time.hh>
#include <memory> // shared_ptr

#include "ros_interface/ParamLoader.h"
#include "ros_interface/GlobalPlan.h"

namespace actor {
namespace core {

/**
 * \brief Target manager
 */
class Target {

public:

	Target();

	// TODO: copy constructor?
	Target(const Target &obj);

	Target(gazebo::physics::WorldPtr world_ptr, std::shared_ptr<const ignition::math::Pose3d> pose_world_ptr,
		   std::shared_ptr<const actor::ros_interface::ParamLoader> params_ptr);

	// FIXME: this was created only for debugging purposes
	void initializeTarget(gazebo::physics::WorldPtr world_ptr, std::shared_ptr<const ignition::math::Pose3d> pose_world_ptr,
			   std::shared_ptr<const actor::ros_interface::ParamLoader> params_ptr);

	void initializeGlobalPlan(std::shared_ptr<ros::NodeHandle> nh_ptr, const size_t &gap, const std::string &frame_id);

	bool setNewTarget(const ignition::math::Vector3d &target);

	/// \brief Method to set new target for actor - static objet's pose
	/// \return True if [x,y] position is valid
	bool setNewTarget(const ignition::math::Pose3d &pose);

	/// \brief Method to set new target for actor - object's name
	/// \return True if object is valid
	bool setNewTarget(const std::string &object_name);

	/// \brief Method to set new target for actor - object's name
	/// \return True if object is valid
	// TODO: stop_after_arrival handling
	bool followObject(const std::string &object_name, const bool &stop_after_arrival);

	/**
	 * @brief Checks whether costmap is already initialized. Calls ROS Service Client.
	 * @note Non-const because internally calls service. Does not change any part of the class though.
	 * @return
	 */
	bool isCostmapInitialized();

	/**
	 * Checks whether global plan was generated for the current target
	 * @return
	 */
	bool isPlanGenerated() const;

	bool isTargetChosen() const;

    /// \brief Helper function to choose a new target location
    bool chooseNewTarget(const gazebo::common::UpdateInfo &info); // const ignition::math::Pose3d &pose_current,

    /// \brief Helper function to check if target is still
    /// reachable (for example after addition of a new model
    /// a current target may not be reachable any more)
    bool isTargetStillReachable(const gazebo::common::UpdateInfo &info);

    /// \brief Helper function to check if target is not
    /// reached for a certain amount of time
    bool isTargetNotReachedForTooLong(const gazebo::common::UpdateInfo &info) const;

    /// \brief TODO:
    bool isTargetReached() const; // const ignition::math::Pose3d &pose_current

    /// \brief TODO
    bool isCheckpointReached() const; 	// const gazebo::common::UpdateInfo &info
    									// const ignition::math::Pose3d &pose_current
    bool generatePathPlan(const ignition::math::Vector3d &target_to_be); // const ignition::math::Pose3d &pose_current,

    void updateCheckpoint();
    ignition::math::Vector3d getCheckpoint() const;
	ignition::math::Vector3d getTarget() const;
	void abandonTarget();



	/// \brief Helper method that checks if a given object is
	/// listed in a ignored_model vector passed in .YAML;
    /// made it static as it will be useful for SFM
	static bool isModelNegligible(const std::string &object_name, const std::vector<std::string> &dictionary);

	nav_msgs::Path getPath() const; // from GlobalPlanner

	virtual ~Target();

private:

	// TODO: new class: TargetManager + queue


	// ====================================================================================================

	/// \brief Helper method that checks if any obstacle's bounding box
	/// does contain the investigated point
	bool doesBoundingBoxContainPoint(const ignition::math::Box &bb, const ignition::math::Vector3d &pt) const;

	// ====================================================================================================


    /// \brief Helper function that check if model of given name exists in the world
    inline std::tuple<bool, gazebo::physics::ModelPtr> isModelValid(const std::string &object_name) const;

    /// \brief Current target location
    ignition::math::Vector3d target_;

    /// \brief Queue of consecutive target locations
    // TODO
    std::queue<ignition::math::Vector3d> target_queue_; // TODO

    /// \brief A certain point from path to target_ (generated by global
    /// planner; it was chosen as closest checkpoint (according to current
    /// position) to the actor's target location
    ignition::math::Vector3d target_checkpoint_;

    /// \brief Time of the last new target selection
	gazebo::common::Time time_last_target_selection_;

    /// \brief Time of the last reachability test.
	gazebo::common::Time time_last_reachability_;

    /// \brief Global plan provider class;
    /// New global plan can be requested via this object
    actor::ros_interface::GlobalPlan global_planner_;
//	std::shared_ptr<actor::ros_interface::GlobalPlan> global_planner_ptr_;

    bool has_target_;
	bool has_global_plan_; // when target is chosen, this flag will be set `false`

	// TODO
	std::shared_ptr<const ignition::math::Pose3d> pose_world_ptr_;
	std::shared_ptr<const actor::ros_interface::ParamLoader> params_ptr_;
	gazebo::physics::WorldPtr world_ptr_; // unable to make it const
};

} /* namespace core */
} /* namespace actor */

#endif /* INCLUDE_CORE_TARGET_H_ */
